
(E) Barsotion KCo GRLIB 1.2

Как использовать библиотеку

(1) Видеобуфер
Графическая библиотека создана для работы с дисплеями формата
128х64 или 240х128. Размер экрана по Y не ограничен. Размер экрана по X
ограничен константой fastmul_rotate (см. GRLIB.def). Максимум - 2040 пикселей.
Прежде чем начать рисовать с помощью библиотеки, необходимо указать, какое
разрешение имеет дисплей. Сделать это можно с помощью функции GR_RESOLUTION.
Также, перед началом работы необходимо указать начальный адрес видеобуфера.
Для этих целей существует функция GR_START_BUF_ADDR.
Подпрограммы копирования видеобуфера в видеопамять дисплея в состав библиотеки
не входят. Предполагается, что они являются частью драйверов дисплея. Дисплеев
существует много разных, для каждого отдельного необходимо писать свой драйвер.
Данная же библиотека универсальна.

Данная графическая библиотека заточена на работу с видеобуфером -- 
областью памяти, которая может быть скопирована в видеопамять
дисплея. Структура видеобуфера представлена на рисунке:

|7------0|--------|--------|--------|~|--------|
|--------|--------|--------|--------|~|--------|

Байты памяти уложены горизонтально. Старший разряд слева, младший -- справа.
Такая организация удобна при работе с дисплеями на контроллере ST7920, где
ячейки памяти тоже уложены "горизонтально". При работе с другими, к примеру,
контроллерами KS0108, где ячейки памяти расположены "вертикально", придется
мудрить с драйвером, драйвер будет медленным.


(2) Адресация
Библиотека имеет удобную сиситему адресации пикселей, где левый верхний пиксель
экрана имеет координаты 0;0, ось Х идет вправо, а ось У - вниз.
Также имеется возможность задавать границы рисуемого. С помощью функции
GR_BORDER можно задать правую, левую, верхнюю и нижнюю границу области
рисования. Точки, которые не попадают в описываемую область, не рисуются.

Установить правильные границы рисуемого очень важно. Важно, чтобы верхняя
и левая границы не были меньше 0, а правая и нижняя не были больше значений
разрешения экрана по Х и У. В противном случае могут пострадать ячейки ОЗУ
за пределами видеобуфера.


(3) Рисование символов
Функцией GR_FONT можно установить начальный адрес таблицы шрифтов.
Таблица шрифтов -- особый бинарный массив. Адресация таблицы происходит
следующим образом:

MSB->|адрес - 5бит|код символа -8бит|номер строки - 3бит|<-LSB

Биты [10:2] шестнадцатиразрядного адреса -- код символа. Старшие [15:11] -
константа, определяющая положение таблицы в памяти.
Имеется возможность рисовать символы высотой 8 или 16 пикселей. В первом
случае 3 младших разряда являются номером строки символа. Во втором случае
номер строки символа - 4 младших разряда адреса, коды символов все должны быть
или только четными, или только нечетными.
Максимальная ширина символа фиксирована и равна 8 пикселям.


(4) Инициализация
Перед тем, как начать рисовать, необходимо вызвать функции GR_RESOLUTION,
GR_START_BUF_ADDR, GR_BORDER, GR_INTERSECTION_STYLE с нужными вам параметрами.
Без этих функций нельзя. Если вы хотите рисовать символы или строки текста,
необходимо установить константы, используя функции GR_FONT, GR_SYM_PARAMETERS,
GR_GAP.

Для ленивых существует функция GR_INI, которая устанавливает константы по
умолчанию. Далее в таблице константы и их значения, устанавливаемые GR_INI.

|-----------------|---------|
|Константа        |Значение |
|-----------------|---------|
|Разрешение Х     |  128    |
|Разрешение У     |  64     |
|Правая граница   |  128    |
|Левая граница    |  0      |
|Верхняя граница  |  0      |
|Нижняя граница   |  64     |
|Адрес буфера     | $F800   |
|Стиль пересечений|  0      |
|Адрес шрифтов    | $1800   |
|Ширина символа   |  6      |
|Высота символа   |  8      |
|Расстояние между |  1      |
|символами        |         |
|-----------------|---------|


(5) Как рисовать
Функции берут вводные значения из стека. Не забудьте загрузить стек перед
вызовом, иначе функция вернет вас не туда, куда вы хотели :) Также важно
соблюдать порядок следования операндов.
Порядок операндов можно увидеть здесь:

; GR_INI () ------------------------ Инициализация библиотеки
; GR_RESOLUTION (X,Y) -------------- Установка разрешения экрана
; GR_START_BUF_ADDR (ADDR) --------- Установка начального адреса видеобуфера
; GR_BORDER (RIGHT,LEFT,UP,DOWN) --- Установка границ отображаемого
; GR_INTERSECTION_STYLE (b) -------- Установка стиля пересечений
; GR_FONT (ADDR) ------------------- Установка начального адреса таблицы шрифтов
; GR_SYM_PARAMETERS (hor,vert) ----- Установка ширины и высоты символа
; GR_GAP (GAP) --------------------- Установка расстояния между символами
; GR_DOT (X,Y) --------------------- Рисование точки
; GR_WRSYM (X,Y,SYM) --------------- Рисование буквы
; GR_STOPT (ADDR,X,Y) -------------- Рисование строки пропорционального текста
; GR_STMONO (ADDR,X,Y) ------------- Рисование строки текста-моно
; GR_LINE (X0,Y0,X1,Y1) ------------ Рисование линий
; GR_CIRCLE (X,Y,R) ---------------- Рисование окружностей
; GR_FRAME (X0,Y0,X1,Y1,R) --------- Рисование скругленных прямоугольников

Пример:

lhld x0
push h
lhld y0
push h
lhld x1
push h
lhld y1
push h
call GR_LINE
hlt

Также примеры можно подсмотреть в файле Unitest_GRLIB.


(6) Стиль пересечений
Функция GR_INTERSECTION_STYLE позволяет изменять стиль пересечений.
Если intersection_style == 0: закрашивание пикселя в любом случае
Если intersection_style[0] == 1: закрашивание, если очищен; очистка, если закрашен
Если intersection_style[0] == 2: очистка пикселя в любом случае


